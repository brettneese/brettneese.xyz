The primary question I study in my work revolves, roughly, around the question: “what does it mean to live digitally.” In other words, most of my work involves taking philosophical theories such and interpreting them in a world where the primary epistemological building block seems to be no longer the atom but the _bit_. What is and isn’t digital, of course, is a tough question, one which I simply do not have space to cover in this short paper. So the reader will have to excuse me for making a giant leap and assuming the realm of the digital as the starting point to examine some of these metaphysical theories (not unlike the way Descartes criticizes theology for beginning with a leap of faith, or Heidegger criticizes metaphysics for beginning with being.) In that world — after that leap — a few questions arise which I’d like to begin to touch on here. 

The first question fundamental question is this: what, precisely, _is_ a computer program? Computers operate by interpreting files called _executables_. Executables, roughly, speaking, a series of instructions that have been “compiled,” or translated from a high-level programming language, such a C, into a lower-level set of instructions, usually assembly. This is because programmers can’t easily write in assembly (itself which must get translated down to the transistor-level bits of off and on states; the “1’s and 0’s .) There are several theories — paradigms, really — around how these upper-level languages structure themselves. By and large, the most popular paradigm is that of what is called object-oriented programming. Object-oriented programming arose out of analytic philosophy, and suggests creating higher-level objects which you can then call on when you need . It’s a method that helps with keeping code DRY: don’t repeat yourself. Once you have a class of a button, you no longer have to worry about all the messy details that all buttons as buttons share. 

For instance, I might define a _class_ called “button,”  I give that button many possible “properties,” such as color and size, and behaviors (perhaps instructions to do when a button is clicked.)  Once I have a _class_ of button, I can go to another part of my code and call upon the button class to _instantiate_ a new button: the syntax varies, of course, by language, but in pseudocode here’s what that looks like:

button = new buttonClass.button({color: red, size: large}) 
button.click(); # calling on the 

It doesn’t take much squinting to see the connections to classical metaphysics at play here. Modern programming languages are fundamentally a rehashing of classical Platonic and neoPlatonic thought. The button class contains within it the Platonic _Idea_ of what it means to be a button, and the button as it appears on the screen can be many colors or sizes, but they are mere _properties_ of the button — the concept of “redness” does not exist within the button itself (the programming language itself usually has a class called “red,” which define “what it means to be red” that can then be applied to many different kinds of objects.) In many ways then — at least for most programmers — the processor, or perhaps the compiler (the thing that transforms high-level code into low-level executables) could be construed as “the One” or “the Good.” For most but the most enlightened programmers, coming to terms with how code actually works on the transistor-level is a daunting if not impossible task: the most studied have only “sort of an idea” at what a processor is really doing. It’s just too darn complex: billions of swtiches quickly alternating between off and on states that form millions of logic gates that actually get the desire work done. The compiler is thus the thing that provides struct: it enlightens them into a sense of being that the computer can understand.

Does this mean that the structure of programming languages suggest something along the lines of “Plato was right?” Here I’m less sure. Yes, the similarities are striking. There are actually reasons for that: early computer science was heavily influenced by the analytic philosophers working around the same time. But there are some problems: the most notable, of course, being that Plato and Aristotle, at least according to Heidegger, don’t really have a terrible fleshed out or concrete idea of non-being; and the structures of true _and_ false are incredibly fundamental to computer science (though Descartes does have an idea of falsity that he lays out in meditation ?? )

More than that, however, it’s important to think through what Heidegger says about metaphysics. Not only does Heidegger have an idea of nothingness: that ideas arise from within , .

 But he also has the suggestion that, in many ways, what we do as humans when granting existence to things in the world is structured not by absolute “reality” but through the structures of our mind. In other words, our metaphysics mirrors the way our brains work. It would make sense, then, that perhaps deconstructing object-oriented programming as a paradigm for structuring the world won’t really get us any closer to a concrete sense of how things _really_ are. Such as project, for Heidegger, is nonsense, because it assumes access to the answer to that question, which is something Heidegger works very hard to ensure is suspect. 

Rather, it may just be that “the structure of programming languages” — and how we build other theories and structures in our world — is more so a reflection of how our brains work, especially with regards to the kind of culture and society those minds find themselves in: in the case of computer science, a society with the concept of absolute true and false; a society with an atomistic, material, definitive grasp on the world. It’s important to note that new theories of computing — such as quantum computing and modern artificial intelligence paradigms — actually reject a lot of fundamental computer science principles, up to and including the reliance on the concept of true and false (quantum bits can have many possible states.) That signals to me that the metaphysics of computer science really rely on a lot of the things Heidegger concerned himself with. For that reason, of all the metaphysicians we read this quarter, I feel compelled to agree with Heidegger the most, especially with regards to the question I proposed earlier: that is, “what, exactly  _is_ a computer program” —  computer programs, roughly, are what they are as a function of human existence itself. 